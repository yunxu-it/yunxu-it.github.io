<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Parcelable 原理 · 有所思</title><meta name="description" content="Parcelable 原理 - Yunxu"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/img/20170901194821_qHtiKc_logo_transparent.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://github.com/yunxu-it/yunxu-it.github.io/atom.xml" title="有所思"><meta name="generator" content="Hexo 5.0.2"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/img/logo_blue_round.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://www.yuque.com/moreve/nycnfq" target="_blank" class="nav-list-link">XUER</a></li><li class="nav-list-item"><a href="https://github.com/yunxu-it" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Parcelable 原理</h1><div class="post-info">2023年04月23日</div><div class="post-content"><h1 id="Parcel-简介"><a href="#Parcel-简介" class="headerlink" title="Parcel 简介"></a>Parcel 简介</h1><p>Parcel 翻译过来是打包的意思, 其实就是包装了我们需要传输的数据, 然后在 Binder 中传输, 也就是用于跨进程传输数据</p>
<p>简单来说，Parcel 提供了一套机制，可以将序列化之后的数据写入到一个共享内存中，其他进程通过 Parcel 可以从这块共享内存中读出字节流，并反序列化成对象</p>
<p><img src="https://s2.loli.net/2023/04/23/CRX87W1V9L6diOT.png" alt="image.png"></p>
<a id="more"></a>

<h1 id="Parcelable-流程"><a href="#Parcelable-流程" class="headerlink" title="Parcelable 流程"></a>Parcelable 流程</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>() : Parcelable &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> index: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> name: String = <span class="string">&quot;name&quot;</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> price: <span class="built_in">Double</span> = <span class="number">1.0</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> checked: <span class="built_in">Boolean</span> = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> child: Child = Child()</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> users: MutableList&lt;Child&gt; = mutableListOf()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(parcel: Parcel) : <span class="keyword">this</span>() &#123;</span><br><span class="line">    index = parcel.readInt()</span><br><span class="line">    name = parcel.readString() ?: <span class="string">&quot;&quot;</span></span><br><span class="line">    price = parcel.readDouble()</span><br><span class="line">    checked = <span class="keyword">if</span> (VERSION.SDK_INT &gt;= VERSION_CODES.Q) &#123;</span><br><span class="line">      parcel.readBoolean()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      parcel.readInt() == <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    child = Child.createFromParcel(parcel)</span><br><span class="line"></span><br><span class="line">    parcel.readList(users, Child::<span class="keyword">class</span>.java.classLoader)</span><br><span class="line">    parcel.readTypedList(users, Child.CREATOR)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">companion</span> <span class="keyword">object</span> CREATOR : Creator&lt;Demo&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">createFromParcel</span><span class="params">(parcel: <span class="type">Parcel</span>)</span></span>: Demo &#123;</span><br><span class="line">      <span class="keyword">return</span> Demo(parcel)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">newArray</span><span class="params">(size: <span class="type">Int</span>)</span></span>: Array&lt;Demo?&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> arrayOfNulls(size)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">describeContents</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">writeToParcel</span><span class="params">(dest: <span class="type">Parcel</span>, flags: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    dest.writeInt(index)</span><br><span class="line">    dest.writeString(name)</span><br><span class="line">    dest.writeDouble(price)</span><br><span class="line">    <span class="keyword">if</span> (VERSION.SDK_INT &gt;= VERSION_CODES.Q) &#123;</span><br><span class="line">      dest.writeBoolean(checked)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      dest.writeInt(<span class="keyword">if</span> (checked) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dest.writeParcelable(child, PARCELABLE_WRITE_RETURN_VALUE)</span><br><span class="line"></span><br><span class="line">    dest.writeList(users)</span><br><span class="line">    dest.writeTypedList(users)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>在写入和读取 <strong>Parcelable</strong> 对象时，Android 框架会检查 <strong>describeContents()</strong> 方法的返回值，并将其作为特性标志的一部分写入或读取到序列化数据中。这样，在接收端读取数据时，就可以根据该标志来确定如何反序列化该对象。[<strong>一般都传 0</strong>]</p>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>通过 writeToParcel 实现序列化，根据传入的参数 dest 写入数据</p>
<h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><p>反序列化需要定义一个 CREATOR 的变量, 也可以自己定义一个 (名字千万不能改), 通过匿名内部类实现 Parcelable 中的 Creator 的接口</p>
<h2 id="特殊类型"><a href="#特殊类型" class="headerlink" title="特殊类型"></a>特殊类型</h2><h3 id="1-Boolean-类型"><a href="#1-Boolean-类型" class="headerlink" title="1. Boolean 类型"></a>1. Boolean 类型</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Android Q 以上提供 writeBoolean 方法，其实内部也是调用 writeInt 方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> void writeBoolean(boolean <span class="keyword">val</span>) &#123;</span><br><span class="line">  writeInt(<span class="keyword">val</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-Parcelable-类"><a href="#2-Parcelable-类" class="headerlink" title="2. Parcelable 类"></a>2. Parcelable 类</h3><h5 id="dest-writeParcelable-child-0"><a href="#dest-writeParcelable-child-0" class="headerlink" title="dest.writeParcelable(child, 0)"></a>dest.writeParcelable(child, 0)</h5><p>注释中写道，序列化对象的时候传入要序列化的对象和一个flags, 这里的 flags 几乎都是0，除非标识当前对象需要作为返回值返回，不能立即释放资源</p>
<h5 id="child-Child-createFromParcel-parcel"><a href="#child-Child-createFromParcel-parcel" class="headerlink" title="child = Child.createFromParcel(parcel)"></a>child = Child.createFromParcel(parcel)</h5><p>通过直接调用 createFromParcel 读取对象</p>
<h3 id="3-List-类"><a href="#3-List-类" class="headerlink" title="3. List 类"></a>3. List 类</h3><h5 id="writeList"><a href="#writeList" class="headerlink" title="writeList"></a>writeList</h5><p>这些方法们把类的信息和数据都写入Parcel，以使将来能使用合适的类装载器重新构造类的实例，所以效率不高</p>
<h5 id="writeTypedList"><a href="#writeTypedList" class="headerlink" title="writeTypedList"></a>writeTypedList</h5><p>这些方法不会写入类的信息，取而代之的是：读取时必须能知道数据属于哪个类并传入正确的Parcelable.Creator来创建对象，而不是直接构造新对象。</p>
<p>更加高效的读写单个Parcelable对象的方法是：直接调用 Parcelable.writeToParcel() 和 Parcelable.Creator.createFromParcel()</p>
<h5 id="readList"><a href="#readList" class="headerlink" title="readList"></a>readList</h5><p>需要传入类加载器来读取，因为写入的时候传入了类的相关信息，如 <code>parcel.readList(users, Child::class.java.classLoader)</code></p>
<p>获取类加载器主要有几种方式     </p>
<blockquote>
<p>getClass().getClassLoader();     </p>
<p>Thread.currentThread().getContextClassLoader();     </p>
<p>Child.class.getClassLoader();</p>
</blockquote>
<h5 id="readTypedList"><a href="#readTypedList" class="headerlink" title="readTypedList"></a>readTypedList</h5><p>需要使用类的CREATOR去获取，如 <code>parcel.readTypedList(users, Child.CREATOR)</code></p>
<h1 id="和-Serializable-区别"><a href="#和-Serializable-区别" class="headerlink" title="和 Serializable 区别"></a>和 Serializable 区别</h1><p>Parcelable 和 Serializable 都是实现序列化并且都可以用于 Intent 间传递数据</p>
<h2 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h2><p>优点：</p>
<ul>
<li>使用起来比较简单，只需要实现 Serializable 接口并重写其中的方法即可。</li>
<li>支持对象图的序列化和反序列化，包含了对象中所有的属性信息。</li>
<li>序列化和反序列化的过程都由虚拟机自动完成，无需手动实现。</li>
</ul>
<p>缺点：</p>
<ul>
<li>序列化和反序列化的过程较为耗时，会对性能产生一定的影响。</li>
<li>反序列化过程中可能存在安全漏洞，因为外部攻击者可以修改序列化的数据，导致反序列化时发生异常或者执行不安全的代码。</li>
</ul>
<p>使用场景：</p>
<ul>
<li>适用于数据对象比较简单，没有复杂嵌套关系的情况下。</li>
</ul>
<h2 id="Parcelable"><a href="#Parcelable" class="headerlink" title="Parcelable"></a>Parcelable</h2><p>优点：</p>
<ul>
<li>序列化和反序列化的过程比 Serializable 更加高效，因为 Parcelable 是在内存中进行序列化和反序列化的，而不是在 IO 流中进行。</li>
<li>Parcelable 在序列化和反序列化过程中可以进行精细控制，能够指定要序列化的字段，可以避免无关数据的传输和浪费。</li>
<li>Parcelable 支持进程间通信，可以用于 Android 中的跨进程通信。</li>
</ul>
<p>缺点：</p>
<ul>
<li>使用起来相对于 Serializable 更为繁琐，需要手动实现 Parcelable 接口。</li>
<li>Parcelable 的序列化和反序列化只能在 Android 系统内进行，无法进行跨平台传输。</li>
</ul>
<p>使用场景：</p>
<ul>
<li>适用于数据对象比较复杂，具有复杂嵌套关系的情况下。</li>
<li>需要实现跨进程通信的情况下。</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/post/20210309-Kotlin-%E5%AF%86%E5%B0%81%E7%B1%BB%E7%9A%84%E4%BC%98%E7%82%B9.html" class="next">NEXT</a></div><!--include partial/comment--><div class="copyright"><p>本站点采用<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank"><u>知识共享 署名-非商业性使用-禁止演绎 4.0 国际许可协议</u></a></p><p>本站点基于<a href="https://hexo.io/" target="_blank">Hexo</a>，采用主题<a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>。<span id=busuanzi_container_site_uv>本站总访问量<span id=busuanzi_value_site_uv></span> 次</span> - © 2014 - 2023</p></div><!--#[a(href=config.url)!= config.author],--></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>