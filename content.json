{"meta":{"title":"有所思","subtitle":"夫君子之学　务求在己而已","description":null,"author":"Yunxu","url":"https://github.com/yunxu-it/yunxu-it.github.io","root":"/"},"pages":[{"title":"关于我","date":"2019-09-04T09:28:26.000Z","updated":"2023-04-22T14:35:12.499Z","comments":true,"path":"about/index.html","permalink":"https://github.com/yunxu-it/yunxu-it.github.io/about/index.html","excerpt":"","text":"简介大学无心插柳上了软件工程，兴趣使然，大多语言皆有涉猎。最爱Linux，Android 和 Python，从15年11月开始一直从事Android开发。 Email: &#121;&#x75;&#x6e;&#120;&#117;&#46;&#x69;&#116;&#x40;&#111;&#x75;&#116;&#108;&#111;&#x6f;&#x6b;&#46;&#99;&#111;&#x6d;Github: https://github.com/yunxu-itResume: Android 开发工程师 座右铭 君子之学，务求在己而已。毁誉荣辱之来，非独不以动其心，且资之以为切磋砥砺之地；故君子无入而不自得，正以其无入而非学也。若夫闻誉而喜，闻毁而戚，则将惶惶于外，惟日之不足矣，其何以为君子？"},{"title":"","date":"2022-04-21T16:00:00.000Z","updated":"2023-04-22T15:02:26.836Z","comments":true,"path":"resume/index.html","permalink":"https://github.com/yunxu-it/yunxu-it.github.io/resume/index.html","excerpt":"","text":"李小龙Android 开发工程师Email: &#121;&#117;&#x6e;&#120;&#117;&#46;&#x69;&#116;&#x40;&#111;&#117;&#116;&#x6c;&#x6f;&#x6f;&#x6b;&#x2e;&#x63;&#x6f;&#x6d; Education: 四川理工学院 软件工程 专业技能 熟练掌握 Java/Kotlin 进⾏ Android 开发，包括各种控件、布局⽅式、动画和⾃定义控件的使⽤⽅法 掌握系统常⽤框架开发，了解屏幕适配、核⼼动画、多线程、版本兼容等功能 熟练使⽤ MVP、MVVM模式进⾏项⽬设计，熟悉常⻅的设计模式，在意建模、封装、继承与接⼝设计 熟练使⽤ RxJava，Retrofit 等三⽅开源框架，掌握 Jetpack 部分组件 熟练掌握 React Native 的开发，包括打包编译、热更新等功能 熟悉 Flutter 项⽬的开发 熟悉 Git/SVN 版本控制，包括协同分⽀管理模式，Git Flow，代码回退等 熟练掌握 Linux/MacOS 终端命令⾏操作 了解React、Vue 等开发框架的开发使⽤，掌握 Taro ⼩程序开发框架 拥有 软件设计师 中级证书 对技术有强烈兴趣，学习能⼒强，技术视野⼴阔，乐于不断学习新知识 工作经验成都墨水儿科技有限公司Android 开发工程师 2021/09 – 2023/03 别的 app基于 Android 的面向全民学习的视频文章教育平台 负责项目整体框架搭建、性能调优和代码重构，实现特殊交互与 UI 完成视频播放模块功能的封装，实现首页万向滑动视频列表功能 完成深度理解模块，文字划重点评论功能 完成笔记编写，集成 Markdown 功能 四川⻓虹智慧健康科技有限公司Android 开发工程师 2020/11 – 2021/09 负责 Android 平台手机端、平板端 app 以及 Flutter 项目的开发与维护 妥妥医用户、医护端基于 Flutter 框架开发的医护 app，为患者、患者家属和医护人员提供服务 负责 app 的功能开发维护与重构 负责 Android 原生代码的封装与维护 完成 Flutter 与 Js 代码交互 妥妥医设备 SDK应项目要求，封装妥妥医医疗硬件对接 sdk，统一设备连接、参数设置、回调接口 负责项目需求整理，项目立项 完成 sdk 封装对接，集成身份证识别器、体温血压血氧血糖心电等设备功能 编写 shell 脚本，为后端自动生成 so 文件与 sdk 压缩包提供一键生成功能 完成签名与有效期验证，在 cpp 文件中实现签名包名验证，以及授权时间验证用以控制 sdk 使用者权限 成都力拓云科技有限公司Android 开发工程师 2015/11 – 2020/11 负责移动端开发，需求对接、整理与评估，Hybird 开发项目的框架选型、技术点攻克 弹窝 app针对地产公司使用，基于 React Native 开发的业务办理 app，可进行在线签约，房源管理，合同管理等操作 负责功能划分，项目任务分配 负责 app 的维护与功能开发 负责移动端发布与上架异常问题研究与解决 建行发布平台基于 Android 平台的广告播控终端 app ，实现对多媒体数据以及网页的自动化解析展示 负责项目整体架构的搭建 完成了自动化任务分发、资源分类下载、设备控制等模块的开发与测试 完成客户端根据节目单生成不同类型网页实现滚动播放的功能"},{"title":"","date":"2017-02-22T16:02:23.000Z","updated":"2023-04-11T10:16:08.787Z","comments":false,"path":"tags/index.html","permalink":"https://github.com/yunxu-it/yunxu-it.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Parcelable 原理","slug":"nature-of-parcelable","date":"2023-04-23T11:24:02.000Z","updated":"2023-04-23T11:30:07.455Z","comments":true,"path":"post/20230423-nature-of-parcelable.html","link":"","permalink":"https://github.com/yunxu-it/yunxu-it.github.io/post/20230423-nature-of-parcelable.html","excerpt":"Parcel 简介Parcel 翻译过来是打包的意思, 其实就是包装了我们需要传输的数据, 然后在 Binder 中传输, 也就是用于跨进程传输数据 简单来说，Parcel 提供了一套机制，可以将序列化之后的数据写入到一个共享内存中，其他进程通过 Parcel 可以从这块共享内存中读出字节流，并反序列化成对象","text":"Parcel 简介Parcel 翻译过来是打包的意思, 其实就是包装了我们需要传输的数据, 然后在 Binder 中传输, 也就是用于跨进程传输数据 简单来说，Parcel 提供了一套机制，可以将序列化之后的数据写入到一个共享内存中，其他进程通过 Parcel 可以从这块共享内存中读出字节流，并反序列化成对象 Parcelable 流程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Demo() : Parcelable &#123; private var index: Int = 0 private var name: String = &quot;name&quot; private var price: Double = 1.0 private var checked: Boolean = false private var child: Child = Child() private var users: MutableList&lt;Child&gt; = mutableListOf() constructor(parcel: Parcel) : this() &#123; index = parcel.readInt() name = parcel.readString() ?: &quot;&quot; price = parcel.readDouble() checked = if (VERSION.SDK_INT &gt;= VERSION_CODES.Q) &#123; parcel.readBoolean() &#125; else &#123; parcel.readInt() == 1 &#125; child = Child.createFromParcel(parcel) parcel.readList(users, Child::class.java.classLoader) parcel.readTypedList(users, Child.CREATOR) &#125; companion object CREATOR : Creator&lt;Demo&gt; &#123; override fun createFromParcel(parcel: Parcel): Demo &#123; return Demo(parcel) &#125; override fun newArray(size: Int): Array&lt;Demo?&gt; &#123; return arrayOfNulls(size) &#125; &#125; override fun describeContents(): Int &#123; return 0 &#125; override fun writeToParcel(dest: Parcel, flags: Int) &#123; dest.writeInt(index) dest.writeString(name) dest.writeDouble(price) if (VERSION.SDK_INT &gt;= VERSION_CODES.Q) &#123; dest.writeBoolean(checked) &#125; else &#123; dest.writeInt(if (checked) 1 else 0) &#125; dest.writeParcelable(child, PARCELABLE_WRITE_RETURN_VALUE) dest.writeList(users) dest.writeTypedList(users) &#125;&#125; 描述在写入和读取 Parcelable 对象时，Android 框架会检查 describeContents() 方法的返回值，并将其作为特性标志的一部分写入或读取到序列化数据中。这样，在接收端读取数据时，就可以根据该标志来确定如何反序列化该对象。[一般都传 0] 序列化通过 writeToParcel 实现序列化，根据传入的参数 dest 写入数据 反序列化反序列化需要定义一个 CREATOR 的变量, 也可以自己定义一个 (名字千万不能改), 通过匿名内部类实现 Parcelable 中的 Creator 的接口 特殊类型1. Boolean 类型1234// Android Q 以上提供 writeBoolean 方法，其实内部也是调用 writeInt 方法public final void writeBoolean(boolean val) &#123; writeInt(val ? 1 : 0);&#125; 2. Parcelable 类dest.writeParcelable(child, 0)注释中写道，序列化对象的时候传入要序列化的对象和一个flags, 这里的 flags 几乎都是0，除非标识当前对象需要作为返回值返回，不能立即释放资源 child = Child.createFromParcel(parcel)通过直接调用 createFromParcel 读取对象 3. List 类writeList这些方法们把类的信息和数据都写入Parcel，以使将来能使用合适的类装载器重新构造类的实例，所以效率不高 writeTypedList这些方法不会写入类的信息，取而代之的是：读取时必须能知道数据属于哪个类并传入正确的Parcelable.Creator来创建对象，而不是直接构造新对象。 更加高效的读写单个Parcelable对象的方法是：直接调用 Parcelable.writeToParcel() 和 Parcelable.Creator.createFromParcel() readList需要传入类加载器来读取，因为写入的时候传入了类的相关信息，如 parcel.readList(users, Child::class.java.classLoader) 获取类加载器主要有几种方式 getClass().getClassLoader(); Thread.currentThread().getContextClassLoader(); Child.class.getClassLoader(); readTypedList需要使用类的CREATOR去获取，如 parcel.readTypedList(users, Child.CREATOR) 和 Serializable 区别Parcelable 和 Serializable 都是实现序列化并且都可以用于 Intent 间传递数据 Serializable优点： 使用起来比较简单，只需要实现 Serializable 接口并重写其中的方法即可。 支持对象图的序列化和反序列化，包含了对象中所有的属性信息。 序列化和反序列化的过程都由虚拟机自动完成，无需手动实现。 缺点： 序列化和反序列化的过程较为耗时，会对性能产生一定的影响。 反序列化过程中可能存在安全漏洞，因为外部攻击者可以修改序列化的数据，导致反序列化时发生异常或者执行不安全的代码。 使用场景： 适用于数据对象比较简单，没有复杂嵌套关系的情况下。 Parcelable优点： 序列化和反序列化的过程比 Serializable 更加高效，因为 Parcelable 是在内存中进行序列化和反序列化的，而不是在 IO 流中进行。 Parcelable 在序列化和反序列化过程中可以进行精细控制，能够指定要序列化的字段，可以避免无关数据的传输和浪费。 Parcelable 支持进程间通信，可以用于 Android 中的跨进程通信。 缺点： 使用起来相对于 Serializable 更为繁琐，需要手动实现 Parcelable 接口。 Parcelable 的序列化和反序列化只能在 Android 系统内进行，无法进行跨平台传输。 使用场景： 适用于数据对象比较复杂，具有复杂嵌套关系的情况下。 需要实现跨进程通信的情况下。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/yunxu-it/yunxu-it.github.io/tags/Android/"}]},{"title":"Kotlin 密封类的优点在哪？","slug":"Kotlin-密封类的优点","date":"2021-03-09T03:27:47.000Z","updated":"2023-04-11T10:16:08.690Z","comments":true,"path":"post/20210309-Kotlin-密封类的优点.html","link":"","permalink":"https://github.com/yunxu-it/yunxu-it.github.io/post/20210309-Kotlin-%E5%AF%86%E5%B0%81%E7%B1%BB%E7%9A%84%E4%BC%98%E7%82%B9.html","excerpt":"kotlin 的官方文档中，对密封类（Sealed Class）的介绍如下 密封类用来表示受限的类继承结构：当一个值为有限几种的类型、而不能有任何其他类型时。 在某种意义上，他们是枚举类的扩展：枚举类型的值集合也是受限的，但每个枚举常量只存在一个实例，而密封类的一个子类可以有可包含状态的多个实例。 其实对密封类与枚举的区别已经表达的很明确了，对比来说就是： 枚举类每种类型只允许有一个实例，而密封类可以有多个 枚举所有常量值类型必须相同，而密封类可以是多种 1234567891011121314151617181920212223enum class Color(val value: Int) &#123; RED(0), BLUE(1), GREEN(2);&#125;sealed class Exprdata class Const(val number: Double) : Expr()data class Text(val content: String) : Expr()data class Sum(val e1: Expr, val e2: Expr) : Expr()object NotANumber : Expr()fun main() &#123; val red1 = Color.RED val red2 = Color.RED println(&quot;$&#123;red1 == red2&#125;&quot;) // true val const1 = Const(1.0) val const2 = Const(2.0) println(&quot;$&#123;const1 == const2&#125;&quot;) // false&#125; 密封类的优点： 密封类拥有抽象类的灵活，子类可以是任意的类，数据类，对象，普通类，甚至密封类 密封类拥有枚举的限制，子类必须写在与密封类同一文件中（kotlin1.1 之前，必须嵌套在密封类声明的内部） 特别 · 当子类涵盖所有情况时，使用 when 表达式，不必添加 else 分支","text":"kotlin 的官方文档中，对密封类（Sealed Class）的介绍如下 密封类用来表示受限的类继承结构：当一个值为有限几种的类型、而不能有任何其他类型时。 在某种意义上，他们是枚举类的扩展：枚举类型的值集合也是受限的，但每个枚举常量只存在一个实例，而密封类的一个子类可以有可包含状态的多个实例。 其实对密封类与枚举的区别已经表达的很明确了，对比来说就是： 枚举类每种类型只允许有一个实例，而密封类可以有多个 枚举所有常量值类型必须相同，而密封类可以是多种 1234567891011121314151617181920212223enum class Color(val value: Int) &#123; RED(0), BLUE(1), GREEN(2);&#125;sealed class Exprdata class Const(val number: Double) : Expr()data class Text(val content: String) : Expr()data class Sum(val e1: Expr, val e2: Expr) : Expr()object NotANumber : Expr()fun main() &#123; val red1 = Color.RED val red2 = Color.RED println(&quot;$&#123;red1 == red2&#125;&quot;) // true val const1 = Const(1.0) val const2 = Const(2.0) println(&quot;$&#123;const1 == const2&#125;&quot;) // false&#125; 密封类的优点： 密封类拥有抽象类的灵活，子类可以是任意的类，数据类，对象，普通类，甚至密封类 密封类拥有枚举的限制，子类必须写在与密封类同一文件中（kotlin1.1 之前，必须嵌套在密封类声明的内部） 特别 · 当子类涵盖所有情况时，使用 when 表达式，不必添加 else 分支 123456fun eval(expr: Expr): Double = when(expr) &#123; is Const -&gt; expr.number is Sum -&gt; eval(expr.e1) + eval(expr.e2) NotANumber -&gt; Double.NaN // 不再需要 `else` 子句，因为我们已经覆盖了所有的情况&#125; 应用场景 网络请求状态封装 1234567891011121314sealed class ResponseResult&lt;out T&gt; &#123; data class Success&lt;out T&gt;(val value: T) : ResponseResult&lt;T&gt;() data class Failure(val throwable: Throwable?) : ResponseResult&lt;Nothing&gt;()&#125;when (result) &#123; is ResponseResult.Failure -&gt; &#123; // 进行失败提示 &#125; is ResponseResult.Success -&gt; &#123; // 进行成功处理 &#125;&#125; 列表数据区分 1234sealed class ListItem &#123; class Text(val title: String, val content: String) : ListItem() class Image(val url: String) : ListItem()&#125; 高级操作·UI 操作封装 12345678910111213sealed class UiOp &#123; object Show: UiOp() object Hide: UiOp() class TranslateX(val px: Float): UiOp() class TranslateY(val px: Float): UiOp()&#125;fun execute(view: View, op: UiOp) = when (op) &#123; UiOp.Show -&gt; view.visibility = View.VISIBLE UiOp.Hide -&gt; view.visibility = View.GONE is UiOp.TranslateX -&gt; view.translationX = op.px is UiOp.TranslateY -&gt; view.translationY = op.px&#125; 原理通过反编译代码，查看 Java 代码实际的实现 1234567891011121314151617181920212223242526// 源代码sealed class Exprobject Const : Expr()// 反编译后，省略部分代码// 方法：Tools → Kotlin → Show Kotlin Bytecode -&gt; DECOMPILE// Expr.javapublic abstract class Expr &#123; private Expr() &#123; &#125; public Expr(DefaultConstructorMarker $constructor_marker) &#123; this(); &#125;&#125;// Const.javapublic final class Const extends Expr &#123; @NotNull public static final Const INSTANCE; private Const() &#123; super((DefaultConstructorMarker)null); &#125;&#125; 可以看出 Const 被编译成了 final class，Expr 被编译成 abstract class，同时生成一个公有的构造方法 构造函数私有化，限制子类必须嵌套在Sealed Class中 生成一个公有的构造函数，在子类的构造函数中调用父类的构造函数 参考文献 Kotlin 中文文档 - 密封类 Kotlin Sealed 是什么？为什么 Google 都用","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://github.com/yunxu-it/yunxu-it.github.io/categories/Kotlin/"}],"tags":[]},{"title":"Linux 上使用 Jenkins 设置 Hexo 自动部署排坑指南","slug":"DeployHexoUseJenkinsOnLinux","date":"2020-11-07T11:17:49.000Z","updated":"2023-04-12T13:48:02.097Z","comments":true,"path":"post/20201107-DeployHexoUseJenkinsOnLinux.html","link":"","permalink":"https://github.com/yunxu-it/yunxu-it.github.io/post/20201107-DeployHexoUseJenkinsOnLinux.html","excerpt":"最近想尝试一下自动化的东西，于是就想起了 Jenkins，但是又没啥特别合适的工作流，就准备试试把我的博客设置为自动部署。 设置的流程我就不细讲了，很简单，而且网上教程很多，下面就列举一些遇到的坑： Ubuntu 安装 jenkins 报错 gpg: no valid OpenPGP data found. 123解决方式：使用以下命令代替curl -L https://pkg.jenkins.io/debian/jenkins.io.key | sudo apt-key add -","text":"最近想尝试一下自动化的东西，于是就想起了 Jenkins，但是又没啥特别合适的工作流，就准备试试把我的博客设置为自动部署。 设置的流程我就不细讲了，很简单，而且网上教程很多，下面就列举一些遇到的坑： Ubuntu 安装 jenkins 报错 gpg: no valid OpenPGP data found. 123解决方式：使用以下命令代替curl -L https://pkg.jenkins.io/debian/jenkins.io.key | sudo apt-key add - jenkins 无法读取 npm 安装以下插件 在全局工具配置 -&gt; NodeJS里面配置安装版本以及需要的全局包 最后在工作流配置的构建环境选择如下配置 基于 gitee 的项目提交触发 Webhook 从而自动部署 安装 gitee 插件 在工作流的构建触发器 完成以下配置（记得点击右下角的生成） 在 gitee 对应的项目设置中生成 WebHook 填写 URL （来自于第 2 步中jenkins 提供的 URL） 填写密码 （来自第 2 步中生成的密码） 添加完成，可以在目录页点击测试 Hexo 中使用 ssh 自动上传，显示认证失败 在服务器创建 ssh key 由于此 key 生成于系统账号下，Jenkins 使用的是自己的账号权限，所以我们需要把系统的 ssh key 复制过去 1234cp ~/.ssh/id_rsa.pub /var/lib/jenkins/.ssh/cp ~/.ssh/id_rsa /var/lib/jenkins/.ssh/# 第一次链接需要手动把 ip 加入信任，所以可以直接把 known_hosts 文件一起复制过去cp ~/.ssh/known_hosts /var/lib/jenkins/.ssh/ 需要把权限所有者改为 Jenkins 1sudo chown jenkins /var/lib/jenkins/.ssh/*","categories":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/yunxu-it/yunxu-it.github.io/categories/Linux/"},{"name":"Jenkins","slug":"Linux/Jenkins","permalink":"https://github.com/yunxu-it/yunxu-it.github.io/categories/Linux/Jenkins/"},{"name":"Hexo","slug":"Linux/Jenkins/Hexo","permalink":"https://github.com/yunxu-it/yunxu-it.github.io/categories/Linux/Jenkins/Hexo/"}],"tags":[]},{"title":"ReactNative 使用自定义字体","slug":"React-Native-Custom-Fonts","date":"2017-07-14T13:04:42.000Z","updated":"2023-04-11T10:16:08.690Z","comments":true,"path":"post/20170714-React-Native-Custom-Fonts.html","link":"","permalink":"https://github.com/yunxu-it/yunxu-it.github.io/post/20170714-React-Native-Custom-Fonts.html","excerpt":"最近公司项目要求，入了RN的坑，作为一个初学者，自然是被坑得体无完肤。 今天就遇到了一个大问题，首页需要一个这样的字体，如下图： 然而，官方文档对自定义字体却毫无提及。 那么，直入主题，网上方法很多，最终解决方法是：","text":"最近公司项目要求，入了RN的坑，作为一个初学者，自然是被坑得体无完肤。 今天就遇到了一个大问题，首页需要一个这样的字体，如下图： 然而，官方文档对自定义字体却毫无提及。 那么，直入主题，网上方法很多，最终解决方法是： 解决方法 把filename.ttf放到&lt;Project Root&gt;/android/app/src/main/assets/fonts文件夹下 在项目目录下使用命令 1234rm -rf ./android/.gradlerm -rf ./android/app/build cd android &amp;&amp; ./gradlew clean &amp;&amp; cd ..// 以上命令极为重要 然后应用字体 1fontFamily:&quot;filename&quot; 最后 1react-native run-android 就是这么简单，但是却坑了我将近一天 其他 如果上述方法不能成功，还有其他方法尝试，但是其他方法于我无效，仅供参考。 其一(地址) Put all your fonts in you React-Native project directory 1./assets/fonts/ Add the following line in your package.json 123&quot;rnpm&quot;: &#123; &quot;assets&quot;: [&quot;./assets/fonts&quot;]&#125; finally run in the terminal from your project directory 1react-native link to use it declare this way in your styles 1fontFamily: &#x27;your-font-name without extension&#x27; If your font is Raleway-Bold.ttf then, 1fontFamily: &#x27;Raleway-Bold&#x27; 其二(地址) 链接中@satya164的回复，代码太长，就不在此贴了，可以跳转过去看。 不过，其方法是对全局的字体进行设置，和我当前需求不符，有此需求的朋友可以试一试。 参考https://github.com/facebook/react-native/issues/1167 https://stackoverflow.com/questions/33088510/react-native-android-fontfamily-does-not-take-effect/37413939#37413939 BTW 作为一个程序员，一定要使用Google，尽量使用英语。 在这次排坑的过程中，最开始我使用的关键词是React Native 自定义字体 Android，最后搜到的结果是千篇一律，百家争抄的景象，不仅过时已久而且格式混乱，可以说就是些垃圾。 后来，我换成了React Native custom font Android，得到的结果多来自于Medium，stackoverflow或Github，最终也是因为它们而解决。","categories":[{"name":"ReactNative","slug":"ReactNative","permalink":"https://github.com/yunxu-it/yunxu-it.github.io/categories/ReactNative/"}],"tags":[]},{"title":"震惊！！！彩票经常出现的数字是它们...","slug":"Lottery-Funny","date":"2017-04-14T15:09:00.000Z","updated":"2023-04-22T14:24:32.182Z","comments":true,"path":"post/20170414-Lottery-Funny.html","link":"","permalink":"https://github.com/yunxu-it/yunxu-it.github.io/post/20170414-Lottery-Funny.html","excerpt":"起因心血来潮，和室友一起买了两注彩票，想着中了五百万怎么花，然而，并没有中……我这种想低投资高回报的光凭运气恐怕不太可能，于是我准备加入概率学的buff。 经过我想了想毕竟不可能所有球都一模一样，总有差异，即使是微乎其微的差异也可能造成出现次数的不均，于是准备用被我冷落许久的python写段代码分析一下。","text":"起因心血来潮，和室友一起买了两注彩票，想着中了五百万怎么花，然而，并没有中……我这种想低投资高回报的光凭运气恐怕不太可能，于是我准备加入概率学的buff。 经过我想了想毕竟不可能所有球都一模一样，总有差异，即使是微乎其微的差异也可能造成出现次数的不均，于是准备用被我冷落许久的python写段代码分析一下。 我开始在网上搜索关于往期开奖记录的api，结果要么收费的要么不能申请，而且数据量太少了，最多几十条，然后在逼乎看到了一条答案，说的是17500.cn有自动更新的文件，还真找到了，我下了txt版的，里面是从2003001期开始，到昨天的所有记录，总共2900多条，我提纯了一下，只保留了每期的七个球纪录。 结果最后统计了一下，还真的有点差异，虽然不是很大上面是红球，下面是蓝球 本来还想看看有没有出现两次的可能，结果一次都没有，想想它的概率，发现自己太异想天开了。 不管了，反正结果就是这样，我选了几个出现比例高的作为固定投注，万一中了呢😜 附件提纯后的数据统计代码","categories":[{"name":"Life","slug":"Life","permalink":"https://github.com/yunxu-it/yunxu-it.github.io/categories/Life/"}],"tags":[]},{"title":"ListView中使用EditView焦点丢失问题","slug":"ListView-EditView-Focus-Lost","date":"2016-03-10T16:43:48.000Z","updated":"2023-04-11T10:16:08.690Z","comments":true,"path":"post/20160311-ListView-EditView-Focus-Lost.html","link":"","permalink":"https://github.com/yunxu-it/yunxu-it.github.io/post/20160311-ListView-EditView-Focus-Lost.html","excerpt":"好久没有更新博客了，好像从开始工作以来，就没有折腾这些东西了。刚好今天遇到个问题，正好记录下来 问题在ListView当中使用EditView时，第一次点击，会弹出小键盘，然后焦点就消失了。 分析第一次点击EditView，弹出小键盘，ListView会调用getView()刷新,然后EditView的焦点就飞了。。。第二次点击，小键盘已经存在，所以不会调用再次刷新，所以焦点不会消失了 思路每次失去焦点之前记录当前View和光标位置，下次调用getView的时候恢复","text":"好久没有更新博客了，好像从开始工作以来，就没有折腾这些东西了。刚好今天遇到个问题，正好记录下来 问题在ListView当中使用EditView时，第一次点击，会弹出小键盘，然后焦点就消失了。 分析第一次点击EditView，弹出小键盘，ListView会调用getView()刷新,然后EditView的焦点就飞了。。。第二次点击，小键盘已经存在，所以不会调用再次刷新，所以焦点不会消失了 思路每次失去焦点之前记录当前View和光标位置，下次调用getView的时候恢复 解决方法目前我用的下面的方法 12345678910111213141516171819202122// 定义两个标记位private int selectIndex = -1; //当前item的位置private int currentSelection = 0;//偏移量// 然后在getView中添加EditView焦点变化的事件，用来记录标记位viewHolder.editView.setOnFocusChangeListener(new OnFocusChangeListener() &#123; @Override public void onFocusChange(View view, boolean arg1) &#123; if(arg1==false)&#123; selectIndex = position; currentSelection = ((EditText)view).getSelectionStart(); &#125; &#125;&#125;);// 在重新绘制View的时候使用该标记位if(position == selectIndex)&#123; viewHolder.editView.requestFocus(); viewHolder.editView.setSelection(currentSelection);&#125; 记住虽然你记录了位置，但是数据并没有记录，每次刷新会重新赋值ListView上的值，需要的话记得保存起来 特技 其实，处理焦点失去还有个更简单的方法，只是有点小瑕疵（如果ListView的下面还有个EditView，会被挤到上面去） 如下 在manifest文件的该ListView所在Activity里添加这一句 1android:windowSoftInputMode=&quot;adjustResize&quot; 你可以试试，确实有效，但是不适合我 还有，我发现这问题，淘宝是用的弹出输入框，哪天试试","categories":[{"name":"Android","slug":"Android","permalink":"https://github.com/yunxu-it/yunxu-it.github.io/categories/Android/"}],"tags":[]},{"title":"Linux下Android真机调试设备配置","slug":"Linux-Android-Device-Debugging","date":"2015-08-06T09:25:21.000Z","updated":"2023-04-11T10:16:08.690Z","comments":true,"path":"post/20150806-Linux-Android-Device-Debugging.html","link":"","permalink":"https://github.com/yunxu-it/yunxu-it.github.io/post/20150806-Linux-Android-Device-Debugging.html","excerpt":"系统环境 Linux Mint 17.2 x64 Kumai_917_V1.5(随便找的一个杂牌机) 方法一 查看设备号 1lsusb 结果 12345678Bus 002 Device 004: ID 0bda:58e6 Realtek Semiconductor Corp. Bus 002 Device 005: ID 04d9:a096 Holtek Semiconductor, Inc. Bus 002 Device 011: ID 05c6:9039 Qualcomm, Inc. Bus 002 Device 003: ID 093a:2521 Pixart Imaging, Inc. Bus 002 Device 002: ID 8087:0024 Intel Corp. Integrated Rate Matching HubBus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hubBus 001 Device 002: ID 8087:0024 Intel Corp. Integrated Rate Matching HubBus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub","text":"系统环境 Linux Mint 17.2 x64 Kumai_917_V1.5(随便找的一个杂牌机) 方法一 查看设备号 1lsusb 结果 12345678Bus 002 Device 004: ID 0bda:58e6 Realtek Semiconductor Corp. Bus 002 Device 005: ID 04d9:a096 Holtek Semiconductor, Inc. Bus 002 Device 011: ID 05c6:9039 Qualcomm, Inc. Bus 002 Device 003: ID 093a:2521 Pixart Imaging, Inc. Bus 002 Device 002: ID 8087:0024 Intel Corp. Integrated Rate Matching HubBus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hubBus 001 Device 002: ID 8087:0024 Intel Corp. Integrated Rate Matching HubBus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub 我的是 1Bus 002 Device 011: ID 05c6:9039 Qualcomm, Inc. 找不到可以试着拔下来尝试查看，根据变化推测你的设备接口 记下你的设备ID后的数字，如05c6 在home 目录下，寻找 .android 目录，如果没有就创建。 在 .android 目录下新建一个文件adb_usb.ini 添加前面获得的数字到 adb_usb.ini 中，如下：10x05c6 跳转最后操作 方法二 输入命令 1sudo vim /etc/udev/rules.d/70-android.rules 插入权限内容（第一行） 12345678SUBSYSTEM==&quot;usb&quot;, ENV&#123;DEVTYPE&#125;==&quot;usb_device&quot;, MODE=&quot;0666&quot;#因为我是杂牌机，所以输的是这个，还有其他的权限，如下#ZTE 19D2SUBSYSTEM==&quot;usb&quot;, ATTR&#123;idVendor&#125;==&quot;19D2&quot;, MODE=&quot;0666&quot;#HTC 0bb4SUBSYSTEM==&quot;usb&quot;, ATTR&#123;idVendor&#125;==&quot;0bb4&quot;, MODE=&quot;0666&quot; 修改权限（不知道需不需要，反正我没用上） 1sudo chmod 777 /etc/udev/rules.d/70-android.rules 最后，重启udev 1sudo service udev restart ADB操作 重新连接下你的设备,然后进入adb所在目录输入以下命令(配了环境变量的人应该懂)12./adb kill-server./adb devices 应该看得到设备出现在目录中了。 参考文章 LINUX下ANDROID开发真机调试 Ubuntu Linux 非root账户运行adb 解决Ubuntu下adb无法识别android真机","categories":[{"name":"Android","slug":"Android","permalink":"https://github.com/yunxu-it/yunxu-it.github.io/categories/Android/"}],"tags":[]},{"title":"Remarkjs 使用Markdown做幻灯片","slug":"Remarkjs_Markdown-PPT","date":"2014-09-19T13:08:50.000Z","updated":"2023-04-11T10:16:08.690Z","comments":true,"path":"post/20140919-Remarkjs_Markdown-PPT.html","link":"","permalink":"https://github.com/yunxu-it/yunxu-it.github.io/post/20140919-Remarkjs_Markdown-PPT.html","excerpt":"最近很喜欢Markdown, 偶然发现了一篇用网页PPT做的命令教程,看起来好高大上的样子。 就是这样↓","text":"最近很喜欢Markdown, 偶然发现了一篇用网页PPT做的命令教程,看起来好高大上的样子。 就是这样↓ 地址在这像黑客一样使用 Linux 命令行不过因为FGW的原因，google字体影响了很多地方，打开有点慢 这是用Remarkjs做的，Remarkjs是一个JavaScript库，用它可以使用Markdown格式来制作幻灯片。 目前，Remarkjs 提供了如下特性： 具有 Presenter 模式，可通过 p 键开启 使用左右或上下方向键进行翻页 支持语法加亮 能够对幻灯进行缩放 支持智能手机、平板等触屏设备 因为直接在浏览器中播放，所以可以跨平台 可是这个要求对CSS比较熟，看来我又要重拾CSS了，真是麻烦。不过反正我就是喜欢没事找事的。 他的模板文件是用的google fonts，做出来难免加载慢，我略改了下 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Title&lt;/title&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;/&gt;&lt;style type=&quot;text/css&quot;&gt;@import url(http://fonts.useso.com/css?family=Yanone+Kaffeesatz);@import url(http://fonts.useso.com/css?family=Droid+Serif:400,700,400italic);@import url(http://fonts.useso.com/css?family=Ubuntu+Mono:400,700,400italic);body &#123; font-family: &#x27;Droid Serif&#x27;; &#125;h1, h2, h3 &#123; font-family: &#x27;Yanone Kaffeesatz&#x27;; font-weight: normal;&#125;.remark-code, .remark-inline-code &#123; font-family: &#x27;Ubuntu Mono&#x27;; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;textarea id=&quot;source&quot;&gt;class: center, middle# Title---# Agenda1. Introduction2. Deep-dive3. ...---# Introduction&lt;/textarea&gt;&lt;script src=&quot;http://gnab.github.io/remark/downloads/remark-latest.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;!--此处的js文件可以下载下来，用相对路径调用--&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;var slideshow = remark.create();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在&lt;textarea&gt;标签之间，添加Markdown内容就行，以---分页如果不喜欢原模版样式，可以自己设计CSS。","categories":[{"name":"Share","slug":"Share","permalink":"https://github.com/yunxu-it/yunxu-it.github.io/categories/Share/"}],"tags":[]},{"title":"优秀程序员不得不知道的20个位运算技巧","slug":"Bit-Operation","date":"2014-09-06T12:11:28.000Z","updated":"2023-04-11T10:16:08.689Z","comments":true,"path":"post/20140906-Bit-Operation.html","link":"","permalink":"https://github.com/yunxu-it/yunxu-it.github.io/post/20140906-Bit-Operation.html","excerpt":"之前在偶然看到这篇文章，看了一下，觉得挺不错的。今天突然想起，却找了好久才找到，所以想收藏在这，免得以后找不到。Welcome To My Bit Tricks=== 获得int型最大值123456789101112131415161718192021int getMaxInt()&#123; return (1 &lt;&lt; 31) - 1; //2147483647， 由于优先级关系，括号不可省略&#125;另一种写法int getMaxInt()&#123; return ~(1 &lt;&lt; 31); //2147483647&#125;另一种写法int getMaxInt()&#123; //有些编译器不适用 return (1 &lt;&lt; -1) - 1; //2147483647&#125;C语言中不知道int占几个字节时候int getMaxInt()&#123; return ((unsigned int) - 1) &gt;&gt; 1; //2147483647&#125;","text":"之前在偶然看到这篇文章，看了一下，觉得挺不错的。今天突然想起，却找了好久才找到，所以想收藏在这，免得以后找不到。Welcome To My Bit Tricks=== 获得int型最大值123456789101112131415161718192021int getMaxInt()&#123; return (1 &lt;&lt; 31) - 1; //2147483647， 由于优先级关系，括号不可省略&#125;另一种写法int getMaxInt()&#123; return ~(1 &lt;&lt; 31); //2147483647&#125;另一种写法int getMaxInt()&#123; //有些编译器不适用 return (1 &lt;&lt; -1) - 1; //2147483647&#125;C语言中不知道int占几个字节时候int getMaxInt()&#123; return ((unsigned int) - 1) &gt;&gt; 1; //2147483647&#125; 获得int型最小值 123456789int getMinInt()&#123; return 1 &lt;&lt; 31; //-2147483648&#125;另一种写法int getMinInt()&#123; //有些编译器不适用 return 1 &lt;&lt; -1; //-2147483648&#125; 获得long类型的最大值 12345678910111213C语言版long getMaxLong()&#123; return ((unsigned long) - 1) &gt;&gt; 1; //2147483647&#125;JAVA版long getMaxLong()&#123; return ((long)1 &lt;&lt; 127) - 1; //9223372036854775807&#125;获得long最小值，和其他类型的最大值，最小值同理. 乘以2运算 123int mulTwo(int n)&#123; //计算n*2 return n &lt;&lt; 1;&#125; 除以2运算 123int divTwo(int n)&#123; //负奇数的运算不可用 return n &gt;&gt; 1; //除以2&#125; 乘以2的m次方 123int mulTwoPower(int n,int m)&#123; //计算n*(2^m) return n &lt;&lt; m;&#125; 除以2的m次方 123int divTwoPower(int n,int m)&#123; //计算n/(2^m) return n &gt;&gt; m;&#125; 判断一个数的奇偶性 123boolean isOddNumber(int n)&#123; return (n &amp; 1) == 1;&#125; 不用临时变量交换两个数（面试常考） 1234567891011C语言版void swap(int *a,int *b)&#123; (*a) ^= (*b) ^= (*a) ^= (*b);&#125;通用版（一些语言中得分开写）a ^= b;b ^= a;a ^= b; 取绝对值（某些机器上，效率比n&gt;0 ? n:-n 高） 1234567int abs(int n)&#123; return (n ^ (n &gt;&gt; 31)) - (n &gt;&gt; 31); /* n&gt;&gt;31 取得n的符号，若n为正数，n&gt;&gt;31等于0， 若n为负数，n&gt;&gt;31等于-1，若n为正数 n^0=0,数不变， 若n为负数有n^-1 需要计算n和-1的补码，然后进行异或运算， 结果n变号并且为n的绝对值减1，再减去-1就是绝对值 */&#125; 取两个数的最大值（某些机器上，效率比a&gt;b ? a:b高） 1234567891011121314通用版int max(int a,int b)&#123; return b &amp; ((a-b) &gt;&gt; 31) | a &amp; (~(a-b) &gt;&gt; 31); /*如果a&gt;=b,(a-b)&gt;&gt;31为0，否则为-1*/&#125;C语言版int max(int x,int y)&#123; return x ^ ((x ^ y) &amp; -(x &lt; y)); /*如果x&lt;y x&lt;y返回1，否则返回0， 与0做与运算结果为0，与-1做与运算结果不变*/&#125; 取两个数的最小值（某些机器上，效率比a&gt;b ? b:a高） 1234567891011121314通用版int min(int a,int b)&#123; return a &amp; ((a-b) &gt;&gt; 31) | b &amp; (~(a-b) &gt;&gt; 31); /*如果a&gt;=b,(a-b)&gt;&gt;31为0，否则为-1*/&#125;C语言版int min(int x,int y)&#123; return y ^ ((x ^ y) &amp; -(x &lt; y)); /*如果x&lt;y x&lt;y返回1，否则返回0， 与0做与运算结果为0，与-1做与运算结果不变*/&#125; 判断符号是否相同 1234boolean isSameSign(int x, int y)&#123; //有0的情况例外 return (x ^ y) &gt;= 0; // true 表示 x和y有相同的符号， false表示x，y有相反的符号。&#125; 计算2的n次方 123int getFactorialofTwo(int n)&#123;//n &gt; 0 return 2 &lt;&lt; (n-1); //2的n次方&#125; 判断一个数是不是2的幂 12345boolean isFactorialofTwo(int n)&#123; return n &gt; 0 ? (n &amp; (n - 1)) == 0 : false; /*如果是2的幂，n一定是100... n-1就是1111.... 所以做与运算结果为0*/&#125; 对2的n次方取余 12345int quyu(int m,int n)&#123;//n为2的次方 return m &amp; (n - 1); /*如果是2的幂，n一定是100... n-1就是1111.... 所以做与运算结果保留m在n范围的非0的位*/&#125; 求两个整数的平均值 1234567891011int getAverage(int x, int y)&#123; return (x + y) &gt;&gt; 1;&#125;另一种写法int getAverage(int x, int y)&#123; return ((x ^ y) &gt;&gt; 1) + (x &amp; y); /*(x^y) &gt;&gt; 1得到x，y其中一个为1的位并除以2， x&amp;y得到x，y都为1的部分，加一起就是平均数了*/&#125; 下面是三个最基本对二进制位的操作 从低位到高位,取n的第m位 123int getBit(int n, int m)&#123; return (n &gt;&gt; (m-1)) &amp; 1;&#125; 从低位到高位.将n的第m位置1 12345int setBitToOne(int n, int m)&#123; return n | (1 &lt;&lt; (m-1)); /*将1左移m-1位找到第m位，得到000...1...000 n在和这个数做或运算*/&#125; 从低位到高位,将n的第m位置0 12345int setBitToZero(int n, int m)&#123; return n &amp; ~(1 &lt;&lt; (m-1)); /* 将1左移m-1位找到第m位，取反后变成111...0...1111 n再和这个数做与运算*/&#125; 另附一些对程序效率上没有实质提高的位运算技巧，一些也是位运算的常识（面试也许会遇到） 计算n+11-~n 计算n-11~-n 取相反数12345~n + 1;另一种写法(n ^ -1) + 1; if(x == a) x = b; if(x == b) x = a;1x = a ^ b ^ x; sign函数，参数为n，当n&gt;0时候返回1，n&lt;0时返回-1，n=0时返回0 1return !!n - (((unsigned)n &gt;&gt; 31) &lt;&lt; 1);","categories":[{"name":"Others","slug":"Others","permalink":"https://github.com/yunxu-it/yunxu-it.github.io/categories/Others/"}],"tags":[]},{"title":"Java操作Excel","slug":"Java-Handle-Excel","date":"2014-09-03T12:55:46.000Z","updated":"2023-04-11T10:16:08.689Z","comments":true,"path":"post/20140903-Java-Handle-Excel.html","link":"","permalink":"https://github.com/yunxu-it/yunxu-it.github.io/post/20140903-Java-Handle-Excel.html","excerpt":"jxl是一个韩国人写的java操作excel的工具, 在开源世界中，有两套比较有影响的API可供使用，一个是POI，一个是jExcelAPI。其中功能相对POI比较弱一点。但jExcelAPI对中文支持非常好，API是纯Java的， 并不依赖Windows系统，即使运行在Linux下，它同样能够正确的处理Excel文件。 另外需要说明的是，这套API对图形和图表的支持很有限，而且仅仅识别PNG格式。 1. 搭建环境2. 基本操作 创建文件 读取文件 修改文件 3. 其他操作 数据化操作 单元格操作","text":"jxl是一个韩国人写的java操作excel的工具, 在开源世界中，有两套比较有影响的API可供使用，一个是POI，一个是jExcelAPI。其中功能相对POI比较弱一点。但jExcelAPI对中文支持非常好，API是纯Java的， 并不依赖Windows系统，即使运行在Linux下，它同样能够正确的处理Excel文件。 另外需要说明的是，这套API对图形和图表的支持很有限，而且仅仅识别PNG格式。 1. 搭建环境2. 基本操作 创建文件 读取文件 修改文件 3. 其他操作 数据化操作 单元格操作 搭建环境 将下载后的文件解包，得到jxl.jar，放入classpath，安装就完成了。（其实我是把它放到lib文件夹下） 基本操作 一、创建文件 拟生成一个名为“test.xls”的Excel文件，其中第一个工作表被命名为“第一页”，大致效果如下：1234567891011121314151617181920212223242526272829303132333435363738package test;//生成Excel的类import java.io.File;import jxl.Workbook;import jxl.write.Label;import jxl.write.WritableSheet;import jxl.write.WritableWorkbook;public class CreateExcel &#123; public static void main(String args[]) &#123; try &#123; // 打开文件 WritableWorkbook book = Workbook.createWorkbook(new File(&quot;test.xls&quot;)); // 生成名为“第一页”的工作表，参数0表示这是第一页 WritableSheet sheet = book.createSheet(&quot;第一页&quot;, 0); // 在Label对象的构造子中指名单元格位置是第一列第一行(0,0) // 以及单元格内容为test Label label = new Label(0, 0, &quot;test&quot;); // 将定义好的单元格添加到工作表中 sheet.addCell(label); /* * 生成一个保存数字的单元格 必须使用Number的完整包路径，否则有语法歧义 单元格位置是第二列，第一行，值为789.123 */ jxl.write.Number number = new jxl.write.Number(1, 0, 555.12541); sheet.addCell(number); // 写入数据并关闭文件 book.write(); book.close(); &#125; catch (Exception e) &#123; System.out.println(e); &#125; &#125;&#125; 编译执行后，会产生一个Excel文件二、读取文件 以刚才我们创建的Excel文件为例，做一个简单的读取操作，程序代码如下：1234567891011121314151617181920212223242526package test;//读取Excel的类import java.io.File;import jxl.Cell;import jxl.Sheet;import jxl.Workbook;public class ReadExcel &#123; public static void main(String args[]) &#123; try &#123; Workbook book = Workbook.getWorkbook(new File(&quot;test.xls&quot;)); // 获得第一个工作表对象 Sheet sheet = book.getSheet(0); // 得到第一列第一行的单元格 Cell cell1 = sheet.getCell(0, 0); String result = cell1.getContents(); System.out.println(result); book.close(); &#125; catch (Exception e) &#123; System.out.println(e); &#125; &#125;&#125;程序执行结果：test 三、修改文件 利用jExcelAPI可以修改已有的Excel文件，修改Excel文件的时候，除了打开文件的方式不同之外，其他操作和创建Excel是一样的。下面的例子是在我们已经生成的Excel文件中添加一个工作表： 12345678910111213141516171819202122232425package test;import java.io.File;import jxl.Workbook;import jxl.write.Label;import jxl.write.WritableSheet;import jxl.write.WritableWorkbook;public class UpdateExcel &#123; public static void main(String args[]) &#123; try &#123; // Excel获得文件 Workbook wb = Workbook.getWorkbook(new File(&quot;test.xls&quot;)); // 打开一个文件的副本，并且指定数据写回到原文件 WritableWorkbook book = Workbook.createWorkbook(new File(&quot;test.xls&quot;),wb); // 添加一个工作表 WritableSheet sheet = book.createSheet(&quot;第二页&quot;, 1); sheet.addCell(new Label(0, 0, &quot;第二页的测试数据&quot;)); book.write(); book.close(); &#125; catch (Exception e) &#123; System.out.println(e); &#125; &#125;&#125; 其他操作 数据格式化在Excel中不涉及复杂的数据类型，能够比较好的处理字串、数字和日期已经能够满足一般的应用。 字串格式化 1234567891011121314151617181920字符串的格式化涉及到的是字体、粗细、字号等元素，这些功能主要由WritableFont和WritableCellFormat类来负责。假设我们在生成一个含有字串的单元格时，使用如下语句，为方便叙述，我们为每一行命令加了编号：WritableFont font1=new WritableFont(WritableFont.TIMES,16,WritableFont.BOLD); ①WritableCellFormat format1=new WritableCellFormat(font1); ②Label label=new Label(0,0,”data 4 test”,format1) ③其中①指定了字串格式：字体为TIMES，字号16，加粗显示。WritableFont有非常丰富的构造子，供不同情况下使用，jExcelAPI的java-doc中有详细列表，这里不再列出。②处代码使用了WritableCellFormat类，这个类非常重要，通过它可以指定单元格的各种属性，后面的单元格格式化中会有更多描述。③处使用了Label类的构造子，指定了字串被赋予那种格式。 在WritableCellFormat类中，还有一个很重要的方法是指定数据的对齐方式，比如针对我们上面的实例，可以指定： //把水平对齐方式指定为居中format1.setAlignment(jxl.format.Alignment.CENTRE); //把垂直对齐方式指定为居中format1.setVerticalAlignment(jxl.format.VerticalAlignment.CENTRE); 单元格操作Excel中很重要的一部分是对单元格的操作，比如行高、列宽、单元格合并等，所幸jExcelAPI提供了这些支持。这些操作相对比较简单，下面只介绍一下相关的API。 合并单元格123456789WritableSheet.mergeCells(int m,int n,int p,int q); //作用是从(m,n)到(p,q)的单元格全部合并，比如：WritableSheet sheet=book.createSheet(“第一页”,0);//合并第一列第一行到第六列第一行的所有单元格sheet.mergeCells(0,0,5,0);合并既可以是横向的，也可以是纵向的。合并后的单元格不能再次进行合并，否则会触发异常。 行高和列宽1234567891011WritableSheet.setRowView(int i,int height);//作用是指定第i+1行的高度，比如：sheet.setRowView(0,200);//将第一行的高度设为200WritableSheet.setColumnView(int i,int width);//作用是指定第i+1列的宽度，比如：sheet.setColumnView(0,30);//将第一列的宽度设为30 jExcelAPI还有其他的一些功能，比如插入图片等，这里就不再一一介绍，读者可以自己探索。 其中：如果读一个excel，需要知道它有多少行和多少列，如下操作： 12345678910111213141516171819Workbook book = Workbook.getWorkbook(new File(&quot;测试1.xls&quot;));// 获得第一个工作表对象Sheet sheet = book.getSheet(0);// 得到第一列第一行的单元格int columnum = sheet.getColumns();// 得到列数int rownum = sheet.getRows();// 得到行数System.out.println(columnum);System.out.println(rownum);for (int i = 0; i &lt; rownum; i++)// 循环进行读写&#123; for (int j = 0; j &lt; columnum; j++) &#123; Cell cell1 = sheet.getCell(j, i); String result = cell1.getContents(); System.out.print(result); System.out.print(&quot;\\t&quot;); &#125; System.out.println();&#125;book.close(); 转自http://www.cnblogs.com/sunzhenxing19860608/archive/2010/12/27/1918128.html","categories":[{"name":"Java","slug":"Java","permalink":"https://github.com/yunxu-it/yunxu-it.github.io/categories/Java/"}],"tags":[]},{"title":"在Linux Mint上安装LAMP集成环境","slug":"Linux-Mint-LAMP","date":"2014-09-03T09:03:58.000Z","updated":"2023-04-11T10:16:08.690Z","comments":true,"path":"post/20140903-Linux-Mint-LAMP.html","link":"","permalink":"https://github.com/yunxu-it/yunxu-it.github.io/post/20140903-Linux-Mint-LAMP.html","excerpt":"这是我在http://community.linuxmint.com发现的教程翻译改编自http://community.linuxmint.com/tutorial/view/486 通过这个教程，你可以学会安装LAMP集成环境。 如果是你在使用PHP，mySQL和Apache做网页设计或网站开发，你一定需要安装这些软件。当我安装了Linux Mint，我搜索了很多关于安装LAMP的方法，然后在一个叫Cargoship的人的网站上发现了这个教程。这个教程是针对Ubuntu的，但是我在Mint上使用，照样成功了。 在这个指南中，我会向你展示怎样在Linux MInt上安装LAMP（Linux，Apache，MySQL，PHP）集成环境。这篇指南旨在帮助那些使用Linux Mint，但还不太熟悉的人。 我们不会讨论如何安装Linux，因为Linux MInt已经安装在你电脑上了。","text":"这是我在http://community.linuxmint.com发现的教程翻译改编自http://community.linuxmint.com/tutorial/view/486 通过这个教程，你可以学会安装LAMP集成环境。 如果是你在使用PHP，mySQL和Apache做网页设计或网站开发，你一定需要安装这些软件。当我安装了Linux Mint，我搜索了很多关于安装LAMP的方法，然后在一个叫Cargoship的人的网站上发现了这个教程。这个教程是针对Ubuntu的，但是我在Mint上使用，照样成功了。 在这个指南中，我会向你展示怎样在Linux MInt上安装LAMP（Linux，Apache，MySQL，PHP）集成环境。这篇指南旨在帮助那些使用Linux Mint，但还不太熟悉的人。 我们不会讨论如何安装Linux，因为Linux MInt已经安装在你电脑上了。 Install Apache 打开终端(应用&gt;附件&gt;终端），也可以使用Ctrl+Alt+t 复制下面的代码并粘贴到终端，回车 1sudo apt-get install apache2 因为是通过管理员权限安装，终端会提示你输入密码 Testing Apache 打开浏览器，在地址栏输入下面地址： 1http://localhost/ 如不能显示,请参照如下方式修改你应该看到一个名为Apache2的文件夹，默认的/。打开它，你会看到一条消息，说：“It works!”，恭喜你！或者类似的东西！ Install PHP 再次打开终端 复制下面的代码粘贴到终端，回车 1sudo apt-get install php5 libapache2-mod-php5 为了让PHP工作并与Apache兼容，我们需要重启Apache，在终端键入以下代码 1sudo /etc/init.d/apache2 restart Test PHP 在终端输入以下代码 1sudo gedit /var/www/testphp.php 打开一个叫testphp.php的文件,复制下面代码到文件中，保存并关闭 1&lt;?php phpinfo(); ?&gt; 现在打开你的浏览器，输入下面地址 1http://localhost/testphp.php 如不能显示,请参照如下方式修改它会告诉你，有你的PHP的所有信息的页面。如果你有一些其他的操作系统安装PHP之前的经验，你一定见过这个页面。 Install MySQL 再次打开终端，输入下面代码 1sudo apt-get install mysql-server （可选）为了让其他网络上的计算机，查看您所创建的服务器，必须先编辑“绑定地址”。通过打开终端编辑my.cnf文件开始。 1sudo gedit /etc/mysql/my.cnf 改变下行 1bind-address = 127.0.0.1 把127.0.0.1设为你的IP地址在Linux Mint系列系统中，终端本身要求设定密码，不必遵循步骤3 下面可能变得很棘手，输入以下代码到终端 1mysql -u root 复制下面的代码并粘贴 1mysql&gt; SET PASSWORD FOR &#x27;root&#x27;@&#x27;localhost&#x27; = PASSWORD(&#x27;yourpassword&#x27;); 务必将yourpassword改成你选择的密码 我们需要安装一个简单的工具（phpmyadmin）来管理你的数据库。复制下列代码并粘贴 1sudo apt-get install libapache2-mod-auth-mysql php5-mysql phpmyadmin 接下来我们需要把PHP和MySQL连接起来，我们需要打开一个叫php.ini的文件。打开并输入下列代码： 1sudo gedit /etc/php5/apache2/php.ini 现在我们需要去掉下行的注释(由于Apache更新,可能mysql.so已经变成msql.so,和原操作操作一样) 1;extension=mysql.so 像这样 1extension=mysql.so 现在需要重启Apache 1sudo /etc/init.d/apache2 restart Tips如果你访问http://localhost/phpmyadmin,出现404错误，你需要配置apache2.conf 1sudo gedit /etc/apache2/apache2.conf 在最后加上这句 1Include /etc/phpmyadmin/apache.conf 重启apache 1sudo /etc/init.d/apache2 restart 由于apache已经有了很大更新，默认首页发生了变化，现在变成了/var/www/html/下，如果想改到www下，输入下面代码 1sudo gedit /etc/apache2/sites-enabled/000-default.conf 找到这行 1DocumentRoot /var/www/html 改为 1DocumentRoot /var/www 保存,然后重启apache 1sudo /etc/init.d/apache2 restart 接下来就是你的事了。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/yunxu-it/yunxu-it.github.io/categories/Linux/"}],"tags":[]},{"title":"PythonChallenge娱乐笔记（未完）","slug":"Python-Challenge-Mark","date":"2014-07-13T15:42:18.000Z","updated":"2023-04-11T10:16:08.690Z","comments":true,"path":"post/20140713-Python-Challenge-Mark.html","link":"","permalink":"https://github.com/yunxu-it/yunxu-it.github.io/post/20140713-Python-Challenge-Mark.html","excerpt":"之前，忘了在哪儿看到这个网站Pythonchalleage，感觉对学习Python有点帮助，就来试了试，发现还是挺有意思的。为了帮助他人（或者说是剧透），我就来写写我的通关笔记。 The First Step http://www.pythonchallenge.com/pc/def/0.html 看图上就是2的38次方，提示让你改变Url地址，你就把地址改为http://www.pythonchallenge.com/pc/def/274877906944.html 就行了","text":"之前，忘了在哪儿看到这个网站Pythonchalleage，感觉对学习Python有点帮助，就来试了试，发现还是挺有意思的。为了帮助他人（或者说是剧透），我就来写写我的通关笔记。 The First Step http://www.pythonchallenge.com/pc/def/0.html 看图上就是2的38次方，提示让你改变Url地址，你就把地址改为http://www.pythonchallenge.com/pc/def/274877906944.html 就行了 The Second Step http://www.pythonchallenge.com/pc/def/map.html 根据图上的规律，把每个单词后移了两位，根据这个，写个程序把下面那串乱序的单词，翻译过来： 1234567891011def add(s): sl = &#x27;&#x27; for w in s: if w == &#x27; &#x27; or w == &#x27;.&#x27; or w == &#x27;(&#x27; or w == &#x27;)&#x27; or w == &quot;&#x27;&quot;: sl += w elif w &gt;= &#x27;y&#x27;: sl += chr(ord(w)-24) else: sl += chr(ord(w)+2) return slprint add(&quot;g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp.bmgle gr gl zw fylb gq glcddgagclr ylb rfyr&#x27;q ufw rfgq rcvrgqqmjmle.sqgleqrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj.&quot;) (写这个时我还没看正则，不够简洁)得到结果，意思就是说让你用string.maketrans()把url翻译了……其实你可以看看现在的url地址，map后移两位换成ocr，通关！ The Third Step http://www.pythonchallenge.com/pc/def/ocr.html 根据页面提示说，字符识别，可能在网页源代码中，看看呗，那。。。。。。。。么多既然让找字符就找呗我把那堆注释放到一个文件里，然后 1234567def find(): for line in open(&#x27;hehe.txt&#x27;): line = line.rstrip(&#x27;\\n&#x27;) for w in line: if w &gt;= &#x27;a&#x27; and w&lt;=&#x27;z&#x27;: print w,find() 结果是equality，下一关…… The Fourth Step http://www.pythonchallenge.com/pc/def/equality.html 这关和上一关差不多，只是规则不一样，是让你找被前后都有三个大写字母包围的小写字母 123456789import redef find(): text = open(&#x27;equality.txt&#x27;,&#x27;r&#x27;) l = &#x27;&#x27; for line in text: if re.findall(&#x27;[^A-Z][A-Z]&#123;3&#125;([a-z])[A-Z]&#123;3&#125;[^A-Z]&#x27;,line)!= []: l += re.findall(&#x27;[^A-Z][A-Z]&#123;3&#125;([a-z])[A-Z]&#123;3&#125;[^A-Z]&#x27;,line)[0] return lprint find() 结果是linkedlist会提示换成.php The Fifth Step http://www.pythonchallenge.com/pc/def/linkedlist.php 点了图片就知道要换nothing值，可是手动明显不现实，不信可以试试现学了下python网络编程 1234567891011121314#!/usr/bin/python#encoing = utf-8import urllibimport rer = urllib.urlopen(&quot;http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=这个值自己换&quot;)while True: s = r.fp.read() l = re.findall(r&quot;[0-9]+&quot;,s) if l == []: break r = urllib.urlopen(&quot;http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=&quot;+l[0]) print l[0] 中间间断一次，显示Yes. Divide by two and keep going.修改程序继续，程序会被误导到82683，回到上一个是82682显示There maybe misleading numbers in the text. One example is 82683. Look only for the next nothing and the next nothing is 63579修改程序继续，最终得到peak.html The Sixth Step http://www.pythonchallenge.com/pc/def/peak.html 这一关算是奇葩了，给你一个山丘的图片，让你pronounce it ，看源代码还说peak hell sounds familiar ? 实在搞不懂，只有求助了，看了攻略才明白要用啥pickle，实在没办法看不懂，直接抄袭了http://www.cnblogs.com/dukeleo/p/3460223.html 12345678910#!/usr/bin/env python# encoding: utf-8import urllibimport pickleurl = &#x27;http://www.pythonchallenge.com/pc/def/banner.p&#x27;rst = urllib.urlopen(url).read()pList = pickle.loads(rst)for item in pList: print &#x27;&#x27;.join([i[0] * i[1] for i in item]) 就这样，结果就是这样，想不到啊，想不到 The Seventh Step http://www.pythonchallenge.com/pc/def/channel.html 这关的图片是拉链(zip),肯定和zip有关了，下载channel.zip，解压之后，出现很多txt文件，根据里面的内容，看来和第五关差不多了。 123456789101112131415161718192021import re import zipfile z = zipfile.ZipFile(&quot;../channel.zip&quot;)name = input(&quot;filename:&quot;)while True: with open(&#x27;&#123;0&#125;.txt&#x27;.format(name),&#x27;r&#x27;) as f: line = f.readlines() if len(line) &gt; 1: print(&#x27;Different file &#123;0&#125;&#x27;.format(name)) else: try: # print(z.getinfo(&quot;&#123;0&#125;.txt&quot;.format(name)).comment.decode(),end=&#x27; &#x27;) p = re.compile(&#x27;[\\d]+&#x27;).findall(line[0]) assert len(p) == 1 name = p[0] except: print(&quot;It&#x27;s the last one,&#123;0&#125;&quot;.format(name)) print(line) break 上了第五关的当，我加了检查误导的代码，结果发现没有误导的指向得到末尾文件是46145.txt内容是Collect the comments.到这里我不懂了，作了下弊，得知zipfile模块有comment的属性用上面注释的语句输出，得出下图到 http://www.pythonchallenge.com/pc/def/hockey.html它说it’s in the air. look at the letters.是氧气oxygen。。。。。呵呵哒 The Eight Step http://www.pythonchallenge.com/pc/def/oxygen.html","categories":[{"name":"Python","slug":"Python","permalink":"https://github.com/yunxu-it/yunxu-it.github.io/categories/Python/"}],"tags":[]}],"categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://github.com/yunxu-it/yunxu-it.github.io/categories/Kotlin/"},{"name":"Linux","slug":"Linux","permalink":"https://github.com/yunxu-it/yunxu-it.github.io/categories/Linux/"},{"name":"Jenkins","slug":"Linux/Jenkins","permalink":"https://github.com/yunxu-it/yunxu-it.github.io/categories/Linux/Jenkins/"},{"name":"Hexo","slug":"Linux/Jenkins/Hexo","permalink":"https://github.com/yunxu-it/yunxu-it.github.io/categories/Linux/Jenkins/Hexo/"},{"name":"ReactNative","slug":"ReactNative","permalink":"https://github.com/yunxu-it/yunxu-it.github.io/categories/ReactNative/"},{"name":"Life","slug":"Life","permalink":"https://github.com/yunxu-it/yunxu-it.github.io/categories/Life/"},{"name":"Android","slug":"Android","permalink":"https://github.com/yunxu-it/yunxu-it.github.io/categories/Android/"},{"name":"Share","slug":"Share","permalink":"https://github.com/yunxu-it/yunxu-it.github.io/categories/Share/"},{"name":"Others","slug":"Others","permalink":"https://github.com/yunxu-it/yunxu-it.github.io/categories/Others/"},{"name":"Java","slug":"Java","permalink":"https://github.com/yunxu-it/yunxu-it.github.io/categories/Java/"},{"name":"Python","slug":"Python","permalink":"https://github.com/yunxu-it/yunxu-it.github.io/categories/Python/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/yunxu-it/yunxu-it.github.io/tags/Android/"}]}